"use strict";(self.webpackChunkaml_website=self.webpackChunkaml_website||[]).push([[675],{3416:(e,n,t)=>{t.d(n,{Z:()=>r});var a=t(7294),i=t(1736);const s={testsUrl:"https://raw.githubusercontent.com/aml-org/examples/master/AMF4/src/test/",mainUrl:"https://raw.githubusercontent.com/aml-org/examples/master/AMF4/src/main/"},o={testsUrl:"https://raw.githubusercontent.com/aml-org/examples/master/AMF5/src/test/",mainUrl:"https://raw.githubusercontent.com/aml-org/examples/master/AMF5/src/main/",scala:"scala/scalaPlatform/",java:"java/javaPlatform/",ts:"ts/"};const r=e=>{let{AMFVersion:n,language:t,example:r,lineStart:l,lineEnd:c,hideLink:m,fromMain:p}=e;const d=(0,a.useRef)(!0),[u,h]=(0,a.useState)(""),[g,x]=(0,a.useState)(""),f=(0,a.useCallback)((async()=>{const e=function(e){return"v4"===e?s:o}(n),a=function(e,n){if(n===s)return"";switch(e){case"scala":default:return n.scala;case"java":return n.java;case"ts":return n.ts;case"js":return n.js}}(t,e),i=(p?e.mainUrl:e.testsUrl)+a+r,m=i.replace("raw.githubusercontent.com/aml-org/examples","github.com/aml-org/examples/tree"),u=await fetch(i),g=await u.text();if(!d.current)return null;if(x(m),h(g),c-l>0){let e=g.split("\n").slice(l,c).join("\n");h(e)}}),[]);return(0,a.useEffect)((()=>(f(),()=>{d.current=!1})),[]),a.createElement("div",null,a.createElement(i.Z,{className:t},u),!m&&a.createElement("p",null,"Code extracted from the examples ",a.createElement("strong",null,a.createElement("a",{href:g},"GitHub repository")),"."))}},8215:(e,n,t)=>{t.d(n,{Z:()=>i});var a=t(7294);const i=function(e){let{children:n,hidden:t,className:i}=e;return a.createElement("div",{role:"tabpanel",hidden:t,className:i},n)}},9877:(e,n,t)=>{t.d(n,{Z:()=>m});var a=t(7462),i=t(7294),s=t(2389),o=t(5773),r=t(6010);const l="tabItem_LplD";function c(e){var n,t,s;const{lazy:c,block:m,defaultValue:p,values:d,groupId:u,className:h}=e,g=i.Children.map(e.children,(e=>{if((0,i.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),x=null!=d?d:g.map((e=>{let{props:{value:n,label:t,attributes:a}}=e;return{value:n,label:t,attributes:a}})),f=(0,o.lx)(x,((e,n)=>e.value===n.value));if(f.length>0)throw new Error('Docusaurus error: Duplicate values "'+f.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.');const v=null===p?p:null!=(n=null!=p?p:null==(t=g.find((e=>e.props.default)))?void 0:t.props.value)?n:null==(s=g[0])?void 0:s.props.value;if(null!==v&&!x.some((e=>e.value===v)))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+v+'" but none of its children has the corresponding value. Available values are: '+x.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");const{tabGroupChoices:b,setTabGroupChoices:k}=(0,o.UB)(),[y,E]=(0,i.useState)(v),A=[],{blockElementScrollPositionUntilNextRender:w}=(0,o.o5)();if(null!=u){const e=b[u];null!=e&&e!==y&&x.some((n=>n.value===e))&&E(e)}const T=e=>{const n=e.currentTarget,t=A.indexOf(n),a=x[t].value;a!==y&&(w(n),E(a),null!=u&&k(u,a))},N=e=>{var n;let t=null;switch(e.key){case"ArrowRight":{const n=A.indexOf(e.currentTarget)+1;t=A[n]||A[0];break}case"ArrowLeft":{const n=A.indexOf(e.currentTarget)-1;t=A[n]||A[A.length-1];break}}null==(n=t)||n.focus()};return i.createElement("div",{className:"tabs-container"},i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":m},h)},x.map((e=>{let{value:n,label:t,attributes:s}=e;return i.createElement("li",(0,a.Z)({role:"tab",tabIndex:y===n?0:-1,"aria-selected":y===n,key:n,ref:e=>A.push(e),onKeyDown:N,onFocus:T,onClick:T},s,{className:(0,r.Z)("tabs__item",l,null==s?void 0:s.className,{"tabs__item--active":y===n})}),null!=t?t:n)}))),c?(0,i.cloneElement)(g.filter((e=>e.props.value===y))[0],{className:"margin-vert--md"}):i.createElement("div",{className:"margin-vert--md"},g.map(((e,n)=>(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==y})))))}function m(e){const n=(0,s.Z)();return i.createElement(c,(0,a.Z)({key:String(n)},e))}},8401:(e,n,t)=>{t.r(n),t.d(n,{frontMatter:()=>l,contentTitle:()=>c,metadata:()=>m,toc:()=>p,default:()=>u});var a=t(7462),i=(t(7294),t(3905)),s=t(9877),o=t(8215),r=t(3416);const l={id:"semantic_extensions",title:"Writing, Applying and Reading Semantic Extensions"},c=void 0,m={unversionedId:"amf/using-amf/semantic_extensions",id:"amf/using-amf/semantic_extensions",title:"Writing, Applying and Reading Semantic Extensions",description:"What you'll learn",source:"@site/docs/amf/using-amf/semantic_extensions.mdx",sourceDirName:"amf/using-amf",slug:"/amf/using-amf/semantic_extensions",permalink:"/a-ml/docs/amf/using-amf/semantic_extensions",editUrl:"https://github.com/aml-org/a-ml/edit/develop/docs/amf/using-amf/semantic_extensions.mdx",tags:[],version:"current",lastUpdatedBy:"Tomas Fernandez",lastUpdatedAt:1645135672,formattedLastUpdatedAt:"2/17/2022",frontMatter:{id:"semantic_extensions",title:"Writing, Applying and Reading Semantic Extensions"},sidebar:"myAutogeneratedSidebar",previous:{title:"AMF Model",permalink:"/a-ml/docs/amf/using-amf/amf_model"},next:{title:"AMF Playground",permalink:"/a-ml/docs/amf/amf_playground"}},p=[{value:"What you&#39;ll learn",id:"what-youll-learn",children:[],level:2},{value:"What a Semantic Extension is",id:"what-a-semantic-extension-is",children:[{value:"Writing a Semantic Extension",id:"writing-a-semantic-extension",children:[{value:"Examining the &quot;DeprecationMapping&quot; annotation",id:"examining-the-deprecationmapping-annotation",children:[],level:4},{value:"Examining the &quot;deprecated&quot; extension",id:"examining-the-deprecated-extension",children:[],level:4}],level:3},{value:"Applying a Semantic Extension in your API",id:"applying-a-semantic-extension-in-your-api",children:[],level:3},{value:"Processing Semantic Extensions in Code",id:"processing-semantic-extensions-in-code",children:[],level:3},{value:"Reading an extension from the Object Oriented interface",id:"reading-an-extension-from-the-object-oriented-interface",children:[],level:3},{value:"Semantic Extension Usage Code Examples",id:"semantic-extension-usage-code-examples",children:[],level:3}],level:2}],d={toc:p};function u(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"what-youll-learn"},"What you'll learn"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"What a Semantic Extension is"),(0,i.kt)("li",{parentName:"ul"},"Writing extensions and applying them in an API spec."),(0,i.kt)("li",{parentName:"ul"},"Processing Semantic Extensions in your code."),(0,i.kt)("li",{parentName:"ul"},"Reading an extension from the Object Oriented interface")),(0,i.kt)("h2",{id:"what-a-semantic-extension-is"},"What a Semantic Extension is"),(0,i.kt)("p",null,'"Semantic Extensions" is a mechanism to extend the semantic domain of an API specification like ',(0,i.kt)("a",{parentName:"p",href:"https://github.com/raml-org/raml-spec/blob/master/versions/raml-10/raml-10.md#annotations"},"RAML"),"\nor ",(0,i.kt)("a",{parentName:"p",href:"https://swagger.io/docs/specification/openapi-extensions/"},"OpenApi"),"."),(0,i.kt)("p",null,"We use ",(0,i.kt)("a",{parentName:"p",href:"/docs/aml/aml"},"AML")," to define mappings that will be describe the AST structure used to parse the nodes that extend the domain of the source specification. Also, it allows map\nthe AST structure to ",(0,i.kt)("em",{parentName:"p"},"semantic terms"),"."),(0,i.kt)("p",null,"We identify such nodes or extension points by using ",(0,i.kt)("em",{parentName:"p"},"annotations")," (also called ",(0,i.kt)("em",{parentName:"p"},"spec extensions"),")."),(0,i.kt)("h3",{id:"writing-a-semantic-extension"},"Writing a Semantic Extension"),(0,i.kt)("p",null,"To write a semantic extension we need to:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Create an AML Dialect document"),(0,i.kt)("li",{parentName:"ul"},'Write an "AnnotationMapping" node under the "annotationMappings" key. This describes the structure that we expect the value of the semantic-extension to have.'),(0,i.kt)("li",{parentName:"ul"},'Declare an extension under the "extensions" node and link it to the AnnotationMapping we wrote.')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'#%Dialect 1.0\ndialect: Repository object extensions\nversion: 1.0\n\nexternal:\n  apiContract: "http://a.ml/vocabularies/apiContract#"\n\ndocuments:\n  root:\n    declares: {}\n\nannotationMappings:\n  DeprecationMapping:\n    domain: apiContract.EndPoint\n    propertyTerm: apiContract.deprecated\n    range: Deprecation\n\nnodeMappings:\n  Deprecation:\n    mapping:\n      replaceFor:\n        range: string\n        mandatory: true\n      message:\n        range: string\n        mandatory: true\n\nextensions:\n  deprecated: DeprecationMapping\n')),(0,i.kt)("h4",{id:"examining-the-deprecationmapping-annotation"},'Examining the "DeprecationMapping" annotation'),(0,i.kt)("p",null,"AnnotationMappings behave like ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/aml-org/aml-spec/blob/master/dialects.md#property-mappings"},"PropertyMappings"),' except that declaring "mapKey" and "mapValue" is not allowed.'),(0,i.kt)("p",null,'The "DeprecationMapping" AnnotationMapping has 3 fields:'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"domain"),': instructs the AMFParser the models that may contain "semantic-extensions". This node\'s value should match a value of the models "@type" array. To see the possible AMF models to extend see: ',(0,i.kt)("a",{parentName:"li",href:"https://github.com/aml-org/amf/blob/develop/documentation/model.md"},"AMFs API Contract Model documentation"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"propertyTerm"),": uri used to semantically describe the parsed extension model. This value will be used in the model to access the extension value. This access is described in the example."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"range"),": desired structure of the semantic-extension's value. This can be a scalar value (string, integer, etc.) or a NodeMapping.")),(0,i.kt)("h4",{id:"examining-the-deprecated-extension"},'Examining the "deprecated" extension'),(0,i.kt)("p",null,'Declarations under the "extensions" node expose an AnnotationMapping under a specific name, in this case "deprecated". An API Spec author or Dialect will be able to use the semantic-extension\nunder the "deprecated" name.'),(0,i.kt)("h3",{id:"applying-a-semantic-extension-in-your-api"},"Applying a Semantic Extension in your API"),(0,i.kt)("p",null,'The "deprecated" extension can now be used under "Endpoint" models in the API. An easy way of getting familiar as to where to write the extension is to use the ',(0,i.kt)("a",{parentName:"p",href:"/docs/AMF/amf_playground"},"AMF Model Playground"),'.\nAn extension that isn\'t under the nodes allowed in the "AnnotationMapping" will be parsed as a "CustomDomainProperty".'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'openapi: 3.0.3\ninfo:\n  title: "Semantic Extension example API"\n  version: 1.0.0\npaths:\n  /v1/paginated:\n    description: "Deprecated endpoint"\n    # Using my "deprecated" semantic extension to add semantic information to the EndPoint\n    x-deprecated:\n      replaceFor: "v2/paginated"\n      message: "Deprecated because the response type has changed."\n    get:\n      responses:\n        "200":\n          description: "An annotated response object with the pagination annotation."\n          # As the AnnotationMapping doesn\'t apply to the "apiContract.Response" domain then this node will be parsed as a CustomDomainProperty\n          x-deprecated:\n            replaceFor: "v3/paginated"\n            message: "Deprecated because the response type has changed."\n')),(0,i.kt)("h3",{id:"processing-semantic-extensions-in-code"},"Processing Semantic Extensions in Code"),(0,i.kt)("p",null,"Using Semantic Extensions in code requires:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Registering the AML Dialect where the extension is defined in an AMFConfiguration"),(0,i.kt)("li",{parentName:"ul"},"Parsing the API . See ",(0,i.kt)("a",{parentName:"li",href:"amf_parsing"},"Parsing")," for more info."),(0,i.kt)("li",{parentName:"ul"},"Transforming it with DEFAULT, EDITING or CACHE pipeline. See ",(0,i.kt)("a",{parentName:"li",href:"amf_transformation"},"Transformation")," for more info.")),(0,i.kt)("p",null,"This is show in the ",(0,i.kt)("a",{parentName:"p",href:"#semantic-extension-usage-code-examples"},"Semantic Extension Examples")),(0,i.kt)("h3",{id:"reading-an-extension-from-the-object-oriented-interface"},"Reading an extension from the Object Oriented interface"),(0,i.kt)("p",null,'Reading a Semantic Extension is not as straightforward as reading "fixed" properties in an AMF model. To read an extension, the "Graph interface" should be used alongside the expanded URI used\nas "propertyTerm" value. This is show in the ',(0,i.kt)("a",{parentName:"p",href:"#semantic-extension-usage-code-examples"},"Semantic Extension Examples")),(0,i.kt)("h3",{id:"semantic-extension-usage-code-examples"},"Semantic Extension Usage Code Examples"),(0,i.kt)(s.Z,{groupId:"languages",defaultValue:"scala",values:[{label:"Scala",value:"scala"},{label:"Java",value:"java"},{label:"TypeScript",value:"ts"}],mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"scala",mdxType:"TabItem"},(0,i.kt)(r.Z,{language:"scala",example:"SemanticExtensionsTest.scala",mdxType:"CodeGetter"})),(0,i.kt)(o.Z,{value:"java",mdxType:"TabItem"},(0,i.kt)(r.Z,{language:"java",example:"SemanticExtensionsTest.java",mdxType:"CodeGetter"})),(0,i.kt)(o.Z,{value:"ts",mdxType:"TabItem"},(0,i.kt)(r.Z,{language:"ts",example:"semantic.extensions.spec.ts",mdxType:"CodeGetter"}))))}u.isMDXComponent=!0}}]);